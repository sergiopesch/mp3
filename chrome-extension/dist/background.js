(()=>{"use strict";async function e(e,t="mp3",r="320"){const o=e.trim();if(!o)return{error:"URL is required"};if(!function(e){try{return new URL(e),!0}catch{return!1}}(o))return{error:"Invalid URL"};try{const{apiEndpoint:e}=await chrome.storage.local.get({apiEndpoint:"http://localhost:3000/api/extract"}),t=await fetch(e,{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify({url:o})});if(!t.ok){let e="Processing service returned an error";try{const r=await t.json();r.error?.code&&(e=r.error.code)}catch{}return{error:e}}const r=await t.json();if("error"===r.status)return{error:r.error?.code||"Failed to process this URL"};if("tunnel"===r.status||"redirect"===r.status)return{downloadUrl:r.url,filename:r.filename||"audio.mp3"};if("picker"===r.status){if(r.audio)return{downloadUrl:r.audio,filename:r.audioFilename||"audio.mp3"};const e=r.picker?.[0];if(e?.url)return{downloadUrl:e.url,filename:"audio.mp3"}}return{error:"Could not extract audio from this URL"}}catch(e){return console.error("Cobalt API error:",e),{error:"Failed to connect to processing service"}}}const t={audioFormat:"mp3",audioBitrate:"320",autoDownload:!0},r="history";class o{static async getHistory(){try{return(await chrome.storage.local.get(r))[r]||[]}catch(e){return console.error("Failed to get history:",e),[]}}static async addHistoryItem(e){try{const t=await this.getHistory(),o=[{...e,id:crypto.randomUUID(),timestamp:Date.now()},...t].slice(0,100);await chrome.storage.local.set({[r]:o})}catch(e){throw console.error("Failed to add history item:",e),e}}static async clearHistory(){try{await chrome.storage.local.set({[r]:[]})}catch(e){throw console.error("Failed to clear history:",e),e}}static async removeHistoryItem(e){try{const t=(await this.getHistory()).filter(t=>t.id!==e);await chrome.storage.local.set({[r]:t})}catch(e){throw console.error("Failed to remove history item:",e),e}}}const a="settings";class n{static async getSettings(){try{return(await chrome.storage.local.get(a))[a]||t}catch(e){return console.error("Failed to get settings:",e),t}}static async updateSettings(e){try{const t={...await this.getSettings(),...e};await chrome.storage.local.set({[a]:t})}catch(e){throw console.error("Failed to update settings:",e),e}}static async resetSettings(){try{await chrome.storage.local.set({[a]:t})}catch(e){throw console.error("Failed to reset settings:",e),e}}}const s="extract-audio",i=new class{constructor(){this.handlers=new Map}register(e,t){this.handlers.set(e,t)}async handle(e,t){const r=this.handlers.get(e.type);if(!r)return console.error(`No handler registered for message type: ${e.type}`),{success:!1,error:"Unknown message type"};try{return await r(e,t)}catch(t){return console.error(`Error handling message ${e.type}:`,t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}listen(){chrome.runtime.onMessage.addListener((e,t,r)=>(this.handle(e,t).then(r).catch(e=>{console.error("Message handling failed:",e),r({success:!1,error:"Internal error"})}),!0))}};i.register("EXTRACT_AUDIO",async function(t,r){const{url:a}=t,s=await n.getSettings(),i=await e(a,s.audioFormat,s.audioBitrate);if("error"in i)return await o.addHistoryItem({url:a,filename:"",downloadUrl:"",status:"error",error:i.error}),{success:!1,error:i.error};if(await o.addHistoryItem({url:a,filename:i.filename,downloadUrl:i.downloadUrl,status:"success"}),s.autoDownload)try{await chrome.downloads.download({url:i.downloadUrl,filename:i.filename,saveAs:!1})}catch(e){console.error("Auto-download failed:",e)}return{success:!0,downloadUrl:i.downloadUrl,filename:i.filename}}),i.register("DOWNLOAD_AUDIO",async function(e,t){const{downloadUrl:r,filename:o}=e;try{return{success:!0,downloadId:await chrome.downloads.download({url:r,filename:o,saveAs:!0})}}catch(e){return console.error("Download failed:",e),{success:!1,error:e instanceof Error?e.message:"Download failed"}}}),i.register("GET_HISTORY",async e=>({history:await o.getHistory()})),i.register("GET_SETTINGS",async e=>({settings:await n.getSettings()})),i.register("UPDATE_SETTINGS",async e=>(await n.updateSettings(e.settings),{success:!0})),i.register("CLEAR_HISTORY",async e=>(await o.clearHistory(),{success:!0})),i.listen(),chrome.runtime.onInstalled.addListener(()=>{chrome.contextMenus.create({id:s,title:"Extract Audio",contexts:["link","page"]})}),chrome.contextMenus.onClicked.addListener(async(t,r)=>{if(t.menuItemId!==s)return;const a=t.linkUrl||t.pageUrl;if(a)try{const t=await n.getSettings(),r=await e(a,t.audioFormat,t.audioBitrate);if("error"in r)return await o.addHistoryItem({url:a,filename:"",downloadUrl:"",status:"error",error:r.error}),void chrome.notifications.create({type:"basic",iconUrl:chrome.runtime.getURL("icons/icon48.png"),title:"Extraction Failed",message:r.error});await o.addHistoryItem({url:a,filename:r.filename,downloadUrl:r.downloadUrl,status:"success"}),t.autoDownload?(await chrome.downloads.download({url:r.downloadUrl,filename:r.filename,saveAs:!1}),chrome.notifications.create({type:"basic",iconUrl:chrome.runtime.getURL("icons/icon48.png"),title:"Audio Extracted",message:`Downloading ${r.filename}`})):chrome.notifications.create({type:"basic",iconUrl:chrome.runtime.getURL("icons/icon48.png"),title:"Audio Extracted",message:`Ready to download ${r.filename}`})}catch(e){console.error("Context menu extraction failed:",e),chrome.notifications.create({type:"basic",iconUrl:chrome.runtime.getURL("icons/icon48.png"),title:"Extraction Failed",message:e instanceof Error?e.message:"Unknown error"})}else console.error("No URL found in context menu click")}),console.log("MP3 Extractor service worker activated"),chrome.runtime.onStartup.addListener(()=>{console.log("Extension started")}),chrome.action.onClicked.addListener(()=>{chrome.action.openPopup()})})();